# third_race
## ------三子棋游戏

## 一. 整体功能
本体旨在设计并制作三子棋游戏装置，能够控制机械臂或其他机构放置棋子，实现人机对弈。
该结构设计的机械结构采用STM32F401CCU6作为主控芯片，拥有84MHz主频，能较好的完成步进电机，舵机，电磁铁的控制。
用树莓派4b作为上位机，搭载usb摄像头采集图像并做图像处理。同时渲染UI界面，便于人机交互。
采用U型框架，使用铝型材和光轴导轨配合轴承组合，利用同步带配个同步轮进行传动
采用电磁铁进行抓取棋子的操作，用舵机齿轮配合自制导轨进行上下移动以便更好地进行控制
在此之上，实现单棋子放置测试（满足要求1）、 多棋子顺序放置测试（满足要求2）、旋转棋盘适应性测试（满足要求3）、装置先手必胜测试（满足要求4）、人先手不输测试（满足要求5）、棋子异常恢复测试（满足要求6）。

## 二. 上位机
### 1. UI画面渲染
选择以pyqt5为主绘制UI界面

主页面有3个按钮，点击后分别进入对应的子页面

#### deploy 页面左侧有一个九宫格，右侧则是一些功能按钮。  
##### 点击Black或者White，该图标变暗，然后点击九宫格就可以在对应小方格内绘制数字。1表示黑子，2表示白子
##### 点击 Deploy按钮，就会把黑白子放置的方格序号以及取子的序号通过串口发送给STM32
##### 点击 Reset 按钮，棋盘上的标记全部消失
##### 点击 Back按钮，可以回到主页面

#### first_gamer，second_gamer是相同的页面，只是点击后下棋的顺序不一样，前者是用户先手，后者是系统先手
##### 页面左侧是实时画面（处理过），右侧是功能按钮
##### status 显示最后的结果，用户是赢还是输还是平局
##### cheat 检测用户是否作弊，如果有会提示
##### save 按键点击后会显示 cheat on ，表示正在进行作弊检测，如果检测到了cheat区域就会爆红
##### ready 按键表示用户已经下完，点击后系统开始规划下棋


### 2. 视频处理
#### 棋盘外的棋子检测
#####   对图像的最左侧和最右侧进行轮廓检测，通过面积筛选一波，然后用外接矩形拟合剩余的轮廓，如果长宽比近似相等，就认为是圆形，记录外接矩形的中心点坐标
#### 棋盘检测
#####   对图像中心进行轮廓检测，取出面积最大的轮廓，用最小旋转矩形拟合，获得4个角点的坐标并按照左上，右上，右下，左下的顺序进行排序
#####   利用相对坐标+旋转坐标系的方法求出9的小矩形的中心点坐标，并且将9个小矩形按照从左到右从上到下的顺序进行编号0-8
#### 棋盘内每个小方格的检测
#####   在检测到棋盘的前提下，在每个矩形内绘制内接圆，在每个内接圆内计算所有像素点的g通道，g通道和r通道的差值的平均值，利用这些值判断白棋，黑棋或者无棋。
#####   为了提高稳定性，取每10帧作为一组数据集


### 3. 对弈算法
#### 通过分析当前棋盘状态，模拟所有可能的未来落子序列，在假设对方也最优策略行棋的前提下，为系统计算出最有利的一步走法。
#### 采用的算法：Minimax（极大极小）算法 + 简化博弈树搜索，同时引入α-β剪枝，减低搜索的复杂度。


### 4. 联合工作
#### 运行程序
运行 main.py，摄像头的视频处理和QT渲染页面同时启动，在2个进程中，不会相互阻塞
##### （1-3）：在deploy 页面完成，通过点击九宫格进行标记(落子序号)，然后再点击Deploy，就把取子和落子的序号发给STM32,其中取子序号是根据黑子或白子分别在(0,5),(5,9)中取不重复的整数得来的
#####         如果点击Rotate ,就会发送旋转后的小方格的序号
##### （4、5）： 用户下完棋后点击Ready 按钮，此时系统根据棋盘状态利用算法得到下一步的最优走法，然后把取子和落子的序号发给STM32；
#####   如果检测到有赢家或者最终平局，就会在status状态栏输出最终结局
##### (6): 点击Save 按钮，会保存棋盘状态并持续检测当前的棋盘状态，如果发现棋盘状态改变则认定用户作弊，在作弊状态栏提示，并把移动棋子的当前位置和存档位置的序号发送个STM32

#### 退出程序
##### 关闭子页面（点击back），只是隐藏了该页面，并没有真正关闭
##### 关闭主页面（点击右上角 X 号），等待摄像头进程也结束后，该进程结束


## 三. 下位机
##### 懒得写了，看看AI生成的吧


## 四. 补充
##### 该方法收光线的扰动较大，需要频繁调参来确保检测的稳定性。
##### 由于没有对棋盘进行透视变换，导致绘制的内接圆可能有些偏差，但是自认为可以增加一定的效率。
##### 最大的问题是，该题要求在棋盘旋转任意角度的情况下完成放置棋子，但是我们误解了题目，以为是固定的转动45°。所以更好的做法是发送每个方格的坐标，即把index 换成 item ,然后让STM32解析坐标，而不是索引。
##### 同样的问题，虽然上面提及盘外棋子的检测，但是实际上也没有用到，因为棋子的坐标也是写死的。
##### 主函数过于冗长繁杂，应该多分几个moudles，更加清晰，也会对后期debug减小不少的负担。

##### 单片机和树莓派之间的通信有待加强

##### 直到到了验收现场，我们才发现，张大头电机驱动可以改加速度的参数，从而使电机转动更丝滑

##### 一定要用PCB啊，这次用面包板搭线，经常断线，需要经常性排查。既浪费时间又损害身心


## 五. 特别鸣谢
##### 队友wjc，负责硬件搭建
##### 队友zhq，全权负责主控板的代码部分
##### GPT老师，帮我debug，优化代码
##### csdn文献 https://blog.csdn.net/shinuone/article/details/131895764 ，帮助我速成 pyqt5
##### github开源项目 https://github.com/ryhxf/2024-NUEDC-E.git ，提供了图像处理部分的思路
##### 最后，感谢辛勤付出的自己

