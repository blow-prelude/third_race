# third_race
## ------三子棋游戏

## 一. 整体功能
#### 自定义布局，通过点击九宫格进行标记，就可以控制棋子底的部署
#### 人机对弈，并配备实时监测反作弊功能

## 二. 上位机
### 1. UI画面渲染
选择以pyqt5为主绘制UI界面

主页面有3个按钮，点击后分别进入对应的子页面

#### deploy 页面左侧有一个九宫格，右侧则是一些功能按钮。  
##### 点击Black或者White，该图标变暗，然后点击九宫格就可以在对应小方格内绘制数字。1表示黑子，2表示白子
##### 点击 Deploy按钮，就会把黑白子放置的方格序号以及取子的序号通过串口发送给STM32
##### 点击 Reset 按钮，棋盘上的标记全部消失
##### 点击 Back按钮，可以回到主页面

#### first_gamer，second_gamer是相同的页面，只是点击后下棋的顺序不一样，前者是用户先手，后者是系统先手
##### 页面左侧是实时画面（处理过），右侧是功能按钮
##### status 显示最后的结果，用户是赢还是输还是平局
##### cheat 检测用户是否作弊，如果有会提示
##### save 按键点击后会显示 cheat on ，表示正在进行作弊检测，如果检测到了cheat区域就会爆红
##### ready 按键表示用户已经下完，点击后系统开始规划下棋


### 2. 视频处理
#### 棋盘外的棋子检测
#####   对图像的最左侧和最右侧进行轮廓检测，通过面积筛选一波，然后用外接矩形拟合剩余的轮廓，如果长宽比近似相等，就认为是圆形，记录外接矩形的中心点坐标
#### 棋盘检测
#####   对图像中心进行轮廓检测，取出面积最大的轮廓，用最小旋转矩形拟合，获得4个角点的坐标并按照左上，右上，右下，左下的顺序进行排序
#####   然后将9个小矩形按照从左到右从上到下的顺序进行编号0-8
#### 棋盘内每个小方格的检测
#####   在检测到棋盘的前提下，在每个矩形内绘制内接圆，在每个内接圆内检测像素灰度的平均值，根据阈值判断是黑还是白还是空



### 3. 联合工作
#### 运行程序
运行 main.py，摄像头的视频处理和QT渲染页面同时启动，在2个进程中，不会相互阻塞
##### （1-3）：在deploy 页面完成，通过点击九宫格进行标记(落子序号)，然后再点击Deploy，就把取子和落子的序号发给STM32,其中取子序号是根据黑子或白子分别在(0,5),(5,10)中取不重复的整数得来的
##### （4、5）： 用户下完棋后点击Ready 按钮，此时系统根据棋盘状态利用算法得到下一步的最优走法，然后把取子和落子的序号发给STM32；
#####   如果检测到有赢家或者最终平局，就会在status状态栏输出最终结局
##### (6): 点击Save 按钮，会保存棋盘状态并持续检测当前的棋盘状态，如果发现棋盘状态改变则认定用户作弊，在作弊状态栏提示，并把移动棋子的当前位置和存档位置的序号发送个STM32

#### 退出程序
##### 关闭子页面（点击back），只是隐藏了该页面，并没有真正关闭
##### 关闭主页面（点击右上角 X 号），等待摄像头进程也结束后，该进程结束


## 三. 下位机


## 四. 特别鸣谢
##### 队友wjc，负责硬件搭建
##### 队友zhq，全权负责主控板的代码部分
##### GPT老师，帮我debug，优化代码
##### csdn文献 https://blog.csdn.net/shinuone/article/details/131895764 ，帮助我速成 pyqt5
##### github开源项目 https://github.com/ryhxf/2024-NUEDC-E.git ，提供了图像处理部分的思路
##### 最后，感谢辛勤付出的自己

